// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'comment.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$CommentDisplayName {
  String get resolvedName => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String resolvedName) integration,
    required TResult Function(String resolvedName) user,
    required TResult Function(String resolvedName) custom,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String resolvedName)? integration,
    TResult? Function(String resolvedName)? user,
    TResult? Function(String resolvedName)? custom,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String resolvedName)? integration,
    TResult Function(String resolvedName)? user,
    TResult Function(String resolvedName)? custom,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(IntegrationDisplayName value) integration,
    required TResult Function(UserDisplayName value) user,
    required TResult Function(CustomDisplayName value) custom,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(IntegrationDisplayName value)? integration,
    TResult? Function(UserDisplayName value)? user,
    TResult? Function(CustomDisplayName value)? custom,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(IntegrationDisplayName value)? integration,
    TResult Function(UserDisplayName value)? user,
    TResult Function(CustomDisplayName value)? custom,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  /// Create a copy of CommentDisplayName
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $CommentDisplayNameCopyWith<CommentDisplayName> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CommentDisplayNameCopyWith<$Res> {
  factory $CommentDisplayNameCopyWith(
          CommentDisplayName value, $Res Function(CommentDisplayName) then) =
      _$CommentDisplayNameCopyWithImpl<$Res, CommentDisplayName>;
  @useResult
  $Res call({String resolvedName});
}

/// @nodoc
class _$CommentDisplayNameCopyWithImpl<$Res, $Val extends CommentDisplayName>
    implements $CommentDisplayNameCopyWith<$Res> {
  _$CommentDisplayNameCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of CommentDisplayName
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resolvedName = null,
  }) {
    return _then(_value.copyWith(
      resolvedName: null == resolvedName
          ? _value.resolvedName
          : resolvedName // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$IntegrationDisplayNameImplCopyWith<$Res>
    implements $CommentDisplayNameCopyWith<$Res> {
  factory _$$IntegrationDisplayNameImplCopyWith(
          _$IntegrationDisplayNameImpl value,
          $Res Function(_$IntegrationDisplayNameImpl) then) =
      __$$IntegrationDisplayNameImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String resolvedName});
}

/// @nodoc
class __$$IntegrationDisplayNameImplCopyWithImpl<$Res>
    extends _$CommentDisplayNameCopyWithImpl<$Res, _$IntegrationDisplayNameImpl>
    implements _$$IntegrationDisplayNameImplCopyWith<$Res> {
  __$$IntegrationDisplayNameImplCopyWithImpl(
      _$IntegrationDisplayNameImpl _value,
      $Res Function(_$IntegrationDisplayNameImpl) _then)
      : super(_value, _then);

  /// Create a copy of CommentDisplayName
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resolvedName = null,
  }) {
    return _then(_$IntegrationDisplayNameImpl(
      resolvedName: null == resolvedName
          ? _value.resolvedName
          : resolvedName // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$IntegrationDisplayNameImpl extends IntegrationDisplayName {
  const _$IntegrationDisplayNameImpl({required this.resolvedName}) : super._();

  @override
  final String resolvedName;

  @override
  String toString() {
    return 'CommentDisplayName.integration(resolvedName: $resolvedName)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$IntegrationDisplayNameImpl &&
            (identical(other.resolvedName, resolvedName) ||
                other.resolvedName == resolvedName));
  }

  @override
  int get hashCode => Object.hash(runtimeType, resolvedName);

  /// Create a copy of CommentDisplayName
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$IntegrationDisplayNameImplCopyWith<_$IntegrationDisplayNameImpl>
      get copyWith => __$$IntegrationDisplayNameImplCopyWithImpl<
          _$IntegrationDisplayNameImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String resolvedName) integration,
    required TResult Function(String resolvedName) user,
    required TResult Function(String resolvedName) custom,
  }) {
    return integration(resolvedName);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String resolvedName)? integration,
    TResult? Function(String resolvedName)? user,
    TResult? Function(String resolvedName)? custom,
  }) {
    return integration?.call(resolvedName);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String resolvedName)? integration,
    TResult Function(String resolvedName)? user,
    TResult Function(String resolvedName)? custom,
    required TResult orElse(),
  }) {
    if (integration != null) {
      return integration(resolvedName);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(IntegrationDisplayName value) integration,
    required TResult Function(UserDisplayName value) user,
    required TResult Function(CustomDisplayName value) custom,
  }) {
    return integration(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(IntegrationDisplayName value)? integration,
    TResult? Function(UserDisplayName value)? user,
    TResult? Function(CustomDisplayName value)? custom,
  }) {
    return integration?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(IntegrationDisplayName value)? integration,
    TResult Function(UserDisplayName value)? user,
    TResult Function(CustomDisplayName value)? custom,
    required TResult orElse(),
  }) {
    if (integration != null) {
      return integration(this);
    }
    return orElse();
  }
}

abstract class IntegrationDisplayName extends CommentDisplayName {
  const factory IntegrationDisplayName({required final String resolvedName}) =
      _$IntegrationDisplayNameImpl;
  const IntegrationDisplayName._() : super._();

  @override
  String get resolvedName;

  /// Create a copy of CommentDisplayName
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$IntegrationDisplayNameImplCopyWith<_$IntegrationDisplayNameImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UserDisplayNameImplCopyWith<$Res>
    implements $CommentDisplayNameCopyWith<$Res> {
  factory _$$UserDisplayNameImplCopyWith(_$UserDisplayNameImpl value,
          $Res Function(_$UserDisplayNameImpl) then) =
      __$$UserDisplayNameImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String resolvedName});
}

/// @nodoc
class __$$UserDisplayNameImplCopyWithImpl<$Res>
    extends _$CommentDisplayNameCopyWithImpl<$Res, _$UserDisplayNameImpl>
    implements _$$UserDisplayNameImplCopyWith<$Res> {
  __$$UserDisplayNameImplCopyWithImpl(
      _$UserDisplayNameImpl _value, $Res Function(_$UserDisplayNameImpl) _then)
      : super(_value, _then);

  /// Create a copy of CommentDisplayName
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resolvedName = null,
  }) {
    return _then(_$UserDisplayNameImpl(
      resolvedName: null == resolvedName
          ? _value.resolvedName
          : resolvedName // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$UserDisplayNameImpl extends UserDisplayName {
  const _$UserDisplayNameImpl({required this.resolvedName}) : super._();

  @override
  final String resolvedName;

  @override
  String toString() {
    return 'CommentDisplayName.user(resolvedName: $resolvedName)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserDisplayNameImpl &&
            (identical(other.resolvedName, resolvedName) ||
                other.resolvedName == resolvedName));
  }

  @override
  int get hashCode => Object.hash(runtimeType, resolvedName);

  /// Create a copy of CommentDisplayName
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$UserDisplayNameImplCopyWith<_$UserDisplayNameImpl> get copyWith =>
      __$$UserDisplayNameImplCopyWithImpl<_$UserDisplayNameImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String resolvedName) integration,
    required TResult Function(String resolvedName) user,
    required TResult Function(String resolvedName) custom,
  }) {
    return user(resolvedName);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String resolvedName)? integration,
    TResult? Function(String resolvedName)? user,
    TResult? Function(String resolvedName)? custom,
  }) {
    return user?.call(resolvedName);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String resolvedName)? integration,
    TResult Function(String resolvedName)? user,
    TResult Function(String resolvedName)? custom,
    required TResult orElse(),
  }) {
    if (user != null) {
      return user(resolvedName);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(IntegrationDisplayName value) integration,
    required TResult Function(UserDisplayName value) user,
    required TResult Function(CustomDisplayName value) custom,
  }) {
    return user(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(IntegrationDisplayName value)? integration,
    TResult? Function(UserDisplayName value)? user,
    TResult? Function(CustomDisplayName value)? custom,
  }) {
    return user?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(IntegrationDisplayName value)? integration,
    TResult Function(UserDisplayName value)? user,
    TResult Function(CustomDisplayName value)? custom,
    required TResult orElse(),
  }) {
    if (user != null) {
      return user(this);
    }
    return orElse();
  }
}

abstract class UserDisplayName extends CommentDisplayName {
  const factory UserDisplayName({required final String resolvedName}) =
      _$UserDisplayNameImpl;
  const UserDisplayName._() : super._();

  @override
  String get resolvedName;

  /// Create a copy of CommentDisplayName
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$UserDisplayNameImplCopyWith<_$UserDisplayNameImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CustomDisplayNameImplCopyWith<$Res>
    implements $CommentDisplayNameCopyWith<$Res> {
  factory _$$CustomDisplayNameImplCopyWith(_$CustomDisplayNameImpl value,
          $Res Function(_$CustomDisplayNameImpl) then) =
      __$$CustomDisplayNameImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String resolvedName});
}

/// @nodoc
class __$$CustomDisplayNameImplCopyWithImpl<$Res>
    extends _$CommentDisplayNameCopyWithImpl<$Res, _$CustomDisplayNameImpl>
    implements _$$CustomDisplayNameImplCopyWith<$Res> {
  __$$CustomDisplayNameImplCopyWithImpl(_$CustomDisplayNameImpl _value,
      $Res Function(_$CustomDisplayNameImpl) _then)
      : super(_value, _then);

  /// Create a copy of CommentDisplayName
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resolvedName = null,
  }) {
    return _then(_$CustomDisplayNameImpl(
      resolvedName: null == resolvedName
          ? _value.resolvedName
          : resolvedName // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$CustomDisplayNameImpl extends CustomDisplayName {
  const _$CustomDisplayNameImpl({required this.resolvedName}) : super._();

  @override
  final String resolvedName;

  @override
  String toString() {
    return 'CommentDisplayName.custom(resolvedName: $resolvedName)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CustomDisplayNameImpl &&
            (identical(other.resolvedName, resolvedName) ||
                other.resolvedName == resolvedName));
  }

  @override
  int get hashCode => Object.hash(runtimeType, resolvedName);

  /// Create a copy of CommentDisplayName
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CustomDisplayNameImplCopyWith<_$CustomDisplayNameImpl> get copyWith =>
      __$$CustomDisplayNameImplCopyWithImpl<_$CustomDisplayNameImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String resolvedName) integration,
    required TResult Function(String resolvedName) user,
    required TResult Function(String resolvedName) custom,
  }) {
    return custom(resolvedName);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String resolvedName)? integration,
    TResult? Function(String resolvedName)? user,
    TResult? Function(String resolvedName)? custom,
  }) {
    return custom?.call(resolvedName);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String resolvedName)? integration,
    TResult Function(String resolvedName)? user,
    TResult Function(String resolvedName)? custom,
    required TResult orElse(),
  }) {
    if (custom != null) {
      return custom(resolvedName);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(IntegrationDisplayName value) integration,
    required TResult Function(UserDisplayName value) user,
    required TResult Function(CustomDisplayName value) custom,
  }) {
    return custom(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(IntegrationDisplayName value)? integration,
    TResult? Function(UserDisplayName value)? user,
    TResult? Function(CustomDisplayName value)? custom,
  }) {
    return custom?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(IntegrationDisplayName value)? integration,
    TResult Function(UserDisplayName value)? user,
    TResult Function(CustomDisplayName value)? custom,
    required TResult orElse(),
  }) {
    if (custom != null) {
      return custom(this);
    }
    return orElse();
  }
}

abstract class CustomDisplayName extends CommentDisplayName {
  const factory CustomDisplayName({required final String resolvedName}) =
      _$CustomDisplayNameImpl;
  const CustomDisplayName._() : super._();

  @override
  String get resolvedName;

  /// Create a copy of CommentDisplayName
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CustomDisplayNameImplCopyWith<_$CustomDisplayNameImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CommentAttachment _$CommentAttachmentFromJson(Map<String, dynamic> json) {
  return _CommentAttachment.fromJson(json);
}

/// @nodoc
mixin _$CommentAttachment {
  String get category => throw _privateConstructorUsedError;
  NotionFile get file => throw _privateConstructorUsedError;

  /// Serializes this CommentAttachment to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of CommentAttachment
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $CommentAttachmentCopyWith<CommentAttachment> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CommentAttachmentCopyWith<$Res> {
  factory $CommentAttachmentCopyWith(
          CommentAttachment value, $Res Function(CommentAttachment) then) =
      _$CommentAttachmentCopyWithImpl<$Res, CommentAttachment>;
  @useResult
  $Res call({String category, NotionFile file});

  $NotionFileCopyWith<$Res> get file;
}

/// @nodoc
class _$CommentAttachmentCopyWithImpl<$Res, $Val extends CommentAttachment>
    implements $CommentAttachmentCopyWith<$Res> {
  _$CommentAttachmentCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of CommentAttachment
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? category = null,
    Object? file = null,
  }) {
    return _then(_value.copyWith(
      category: null == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as String,
      file: null == file
          ? _value.file
          : file // ignore: cast_nullable_to_non_nullable
              as NotionFile,
    ) as $Val);
  }

  /// Create a copy of CommentAttachment
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $NotionFileCopyWith<$Res> get file {
    return $NotionFileCopyWith<$Res>(_value.file, (value) {
      return _then(_value.copyWith(file: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CommentAttachmentImplCopyWith<$Res>
    implements $CommentAttachmentCopyWith<$Res> {
  factory _$$CommentAttachmentImplCopyWith(_$CommentAttachmentImpl value,
          $Res Function(_$CommentAttachmentImpl) then) =
      __$$CommentAttachmentImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String category, NotionFile file});

  @override
  $NotionFileCopyWith<$Res> get file;
}

/// @nodoc
class __$$CommentAttachmentImplCopyWithImpl<$Res>
    extends _$CommentAttachmentCopyWithImpl<$Res, _$CommentAttachmentImpl>
    implements _$$CommentAttachmentImplCopyWith<$Res> {
  __$$CommentAttachmentImplCopyWithImpl(_$CommentAttachmentImpl _value,
      $Res Function(_$CommentAttachmentImpl) _then)
      : super(_value, _then);

  /// Create a copy of CommentAttachment
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? category = null,
    Object? file = null,
  }) {
    return _then(_$CommentAttachmentImpl(
      category: null == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as String,
      file: null == file
          ? _value.file
          : file // ignore: cast_nullable_to_non_nullable
              as NotionFile,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CommentAttachmentImpl extends _CommentAttachment {
  const _$CommentAttachmentImpl({required this.category, required this.file})
      : super._();

  factory _$CommentAttachmentImpl.fromJson(Map<String, dynamic> json) =>
      _$$CommentAttachmentImplFromJson(json);

  @override
  final String category;
  @override
  final NotionFile file;

  @override
  String toString() {
    return 'CommentAttachment(category: $category, file: $file)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CommentAttachmentImpl &&
            (identical(other.category, category) ||
                other.category == category) &&
            (identical(other.file, file) || other.file == file));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, category, file);

  /// Create a copy of CommentAttachment
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CommentAttachmentImplCopyWith<_$CommentAttachmentImpl> get copyWith =>
      __$$CommentAttachmentImplCopyWithImpl<_$CommentAttachmentImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CommentAttachmentImplToJson(
      this,
    );
  }
}

abstract class _CommentAttachment extends CommentAttachment {
  const factory _CommentAttachment(
      {required final String category,
      required final NotionFile file}) = _$CommentAttachmentImpl;
  const _CommentAttachment._() : super._();

  factory _CommentAttachment.fromJson(Map<String, dynamic> json) =
      _$CommentAttachmentImpl.fromJson;

  @override
  String get category;
  @override
  NotionFile get file;

  /// Create a copy of CommentAttachment
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CommentAttachmentImplCopyWith<_$CommentAttachmentImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Comment _$CommentFromJson(Map<String, dynamic> json) {
  return _Comment.fromJson(json);
}

/// @nodoc
mixin _$Comment {
  String get object => throw _privateConstructorUsedError;
  String get id => throw _privateConstructorUsedError;
  Parent get parent => throw _privateConstructorUsedError;
  String get discussionId => throw _privateConstructorUsedError;
  DateTime get createdTime => throw _privateConstructorUsedError;
  DateTime get lastEditedTime => throw _privateConstructorUsedError;
  User get createdBy => throw _privateConstructorUsedError;
  List<RichText> get richText => throw _privateConstructorUsedError;
  List<CommentAttachment>? get attachments =>
      throw _privateConstructorUsedError;
  CommentDisplayName? get displayName => throw _privateConstructorUsedError;

  /// Serializes this Comment to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of Comment
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $CommentCopyWith<Comment> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CommentCopyWith<$Res> {
  factory $CommentCopyWith(Comment value, $Res Function(Comment) then) =
      _$CommentCopyWithImpl<$Res, Comment>;
  @useResult
  $Res call(
      {String object,
      String id,
      Parent parent,
      String discussionId,
      DateTime createdTime,
      DateTime lastEditedTime,
      User createdBy,
      List<RichText> richText,
      List<CommentAttachment>? attachments,
      CommentDisplayName? displayName});

  $ParentCopyWith<$Res> get parent;
  $UserCopyWith<$Res> get createdBy;
  $CommentDisplayNameCopyWith<$Res>? get displayName;
}

/// @nodoc
class _$CommentCopyWithImpl<$Res, $Val extends Comment>
    implements $CommentCopyWith<$Res> {
  _$CommentCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Comment
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? object = null,
    Object? id = null,
    Object? parent = null,
    Object? discussionId = null,
    Object? createdTime = null,
    Object? lastEditedTime = null,
    Object? createdBy = null,
    Object? richText = null,
    Object? attachments = freezed,
    Object? displayName = freezed,
  }) {
    return _then(_value.copyWith(
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      parent: null == parent
          ? _value.parent
          : parent // ignore: cast_nullable_to_non_nullable
              as Parent,
      discussionId: null == discussionId
          ? _value.discussionId
          : discussionId // ignore: cast_nullable_to_non_nullable
              as String,
      createdTime: null == createdTime
          ? _value.createdTime
          : createdTime // ignore: cast_nullable_to_non_nullable
              as DateTime,
      lastEditedTime: null == lastEditedTime
          ? _value.lastEditedTime
          : lastEditedTime // ignore: cast_nullable_to_non_nullable
              as DateTime,
      createdBy: null == createdBy
          ? _value.createdBy
          : createdBy // ignore: cast_nullable_to_non_nullable
              as User,
      richText: null == richText
          ? _value.richText
          : richText // ignore: cast_nullable_to_non_nullable
              as List<RichText>,
      attachments: freezed == attachments
          ? _value.attachments
          : attachments // ignore: cast_nullable_to_non_nullable
              as List<CommentAttachment>?,
      displayName: freezed == displayName
          ? _value.displayName
          : displayName // ignore: cast_nullable_to_non_nullable
              as CommentDisplayName?,
    ) as $Val);
  }

  /// Create a copy of Comment
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ParentCopyWith<$Res> get parent {
    return $ParentCopyWith<$Res>(_value.parent, (value) {
      return _then(_value.copyWith(parent: value) as $Val);
    });
  }

  /// Create a copy of Comment
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserCopyWith<$Res> get createdBy {
    return $UserCopyWith<$Res>(_value.createdBy, (value) {
      return _then(_value.copyWith(createdBy: value) as $Val);
    });
  }

  /// Create a copy of Comment
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CommentDisplayNameCopyWith<$Res>? get displayName {
    if (_value.displayName == null) {
      return null;
    }

    return $CommentDisplayNameCopyWith<$Res>(_value.displayName!, (value) {
      return _then(_value.copyWith(displayName: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CommentImplCopyWith<$Res> implements $CommentCopyWith<$Res> {
  factory _$$CommentImplCopyWith(
          _$CommentImpl value, $Res Function(_$CommentImpl) then) =
      __$$CommentImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String object,
      String id,
      Parent parent,
      String discussionId,
      DateTime createdTime,
      DateTime lastEditedTime,
      User createdBy,
      List<RichText> richText,
      List<CommentAttachment>? attachments,
      CommentDisplayName? displayName});

  @override
  $ParentCopyWith<$Res> get parent;
  @override
  $UserCopyWith<$Res> get createdBy;
  @override
  $CommentDisplayNameCopyWith<$Res>? get displayName;
}

/// @nodoc
class __$$CommentImplCopyWithImpl<$Res>
    extends _$CommentCopyWithImpl<$Res, _$CommentImpl>
    implements _$$CommentImplCopyWith<$Res> {
  __$$CommentImplCopyWithImpl(
      _$CommentImpl _value, $Res Function(_$CommentImpl) _then)
      : super(_value, _then);

  /// Create a copy of Comment
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? object = null,
    Object? id = null,
    Object? parent = null,
    Object? discussionId = null,
    Object? createdTime = null,
    Object? lastEditedTime = null,
    Object? createdBy = null,
    Object? richText = null,
    Object? attachments = freezed,
    Object? displayName = freezed,
  }) {
    return _then(_$CommentImpl(
      object: null == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String,
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      parent: null == parent
          ? _value.parent
          : parent // ignore: cast_nullable_to_non_nullable
              as Parent,
      discussionId: null == discussionId
          ? _value.discussionId
          : discussionId // ignore: cast_nullable_to_non_nullable
              as String,
      createdTime: null == createdTime
          ? _value.createdTime
          : createdTime // ignore: cast_nullable_to_non_nullable
              as DateTime,
      lastEditedTime: null == lastEditedTime
          ? _value.lastEditedTime
          : lastEditedTime // ignore: cast_nullable_to_non_nullable
              as DateTime,
      createdBy: null == createdBy
          ? _value.createdBy
          : createdBy // ignore: cast_nullable_to_non_nullable
              as User,
      richText: null == richText
          ? _value._richText
          : richText // ignore: cast_nullable_to_non_nullable
              as List<RichText>,
      attachments: freezed == attachments
          ? _value._attachments
          : attachments // ignore: cast_nullable_to_non_nullable
              as List<CommentAttachment>?,
      displayName: freezed == displayName
          ? _value.displayName
          : displayName // ignore: cast_nullable_to_non_nullable
              as CommentDisplayName?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CommentImpl extends _Comment {
  const _$CommentImpl(
      {required this.object,
      required this.id,
      required this.parent,
      required this.discussionId,
      required this.createdTime,
      required this.lastEditedTime,
      required this.createdBy,
      required final List<RichText> richText,
      final List<CommentAttachment>? attachments,
      this.displayName})
      : _richText = richText,
        _attachments = attachments,
        super._();

  factory _$CommentImpl.fromJson(Map<String, dynamic> json) =>
      _$$CommentImplFromJson(json);

  @override
  final String object;
  @override
  final String id;
  @override
  final Parent parent;
  @override
  final String discussionId;
  @override
  final DateTime createdTime;
  @override
  final DateTime lastEditedTime;
  @override
  final User createdBy;
  final List<RichText> _richText;
  @override
  List<RichText> get richText {
    if (_richText is EqualUnmodifiableListView) return _richText;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_richText);
  }

  final List<CommentAttachment>? _attachments;
  @override
  List<CommentAttachment>? get attachments {
    final value = _attachments;
    if (value == null) return null;
    if (_attachments is EqualUnmodifiableListView) return _attachments;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final CommentDisplayName? displayName;

  @override
  String toString() {
    return 'Comment(object: $object, id: $id, parent: $parent, discussionId: $discussionId, createdTime: $createdTime, lastEditedTime: $lastEditedTime, createdBy: $createdBy, richText: $richText, attachments: $attachments, displayName: $displayName)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CommentImpl &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.parent, parent) || other.parent == parent) &&
            (identical(other.discussionId, discussionId) ||
                other.discussionId == discussionId) &&
            (identical(other.createdTime, createdTime) ||
                other.createdTime == createdTime) &&
            (identical(other.lastEditedTime, lastEditedTime) ||
                other.lastEditedTime == lastEditedTime) &&
            (identical(other.createdBy, createdBy) ||
                other.createdBy == createdBy) &&
            const DeepCollectionEquality().equals(other._richText, _richText) &&
            const DeepCollectionEquality()
                .equals(other._attachments, _attachments) &&
            (identical(other.displayName, displayName) ||
                other.displayName == displayName));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      object,
      id,
      parent,
      discussionId,
      createdTime,
      lastEditedTime,
      createdBy,
      const DeepCollectionEquality().hash(_richText),
      const DeepCollectionEquality().hash(_attachments),
      displayName);

  /// Create a copy of Comment
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CommentImplCopyWith<_$CommentImpl> get copyWith =>
      __$$CommentImplCopyWithImpl<_$CommentImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CommentImplToJson(
      this,
    );
  }
}

abstract class _Comment extends Comment {
  const factory _Comment(
      {required final String object,
      required final String id,
      required final Parent parent,
      required final String discussionId,
      required final DateTime createdTime,
      required final DateTime lastEditedTime,
      required final User createdBy,
      required final List<RichText> richText,
      final List<CommentAttachment>? attachments,
      final CommentDisplayName? displayName}) = _$CommentImpl;
  const _Comment._() : super._();

  factory _Comment.fromJson(Map<String, dynamic> json) = _$CommentImpl.fromJson;

  @override
  String get object;
  @override
  String get id;
  @override
  Parent get parent;
  @override
  String get discussionId;
  @override
  DateTime get createdTime;
  @override
  DateTime get lastEditedTime;
  @override
  User get createdBy;
  @override
  List<RichText> get richText;
  @override
  List<CommentAttachment>? get attachments;
  @override
  CommentDisplayName? get displayName;

  /// Create a copy of Comment
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CommentImplCopyWith<_$CommentImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
